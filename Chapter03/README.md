# Chapter 03

## 3.1 기이한 이름 (Mysterious Name)
코드는 단순하고 명료하게 작성해야 하며, 코드를 명료하게 표현하는 데 중요한 요소 하나는 '이름'이다.
때문에 많이 사용되는 리팩터링 기법 또한 **함수 선언 바꾸기**, **변수 이름 바꾸기**, **필드 이름 바꾸기**처럼 이름을 바꾸는 리팩터링이다.
혼란스러운 이름을 잘 정리하다 보면 코드가 간결해질 때가 많다.

## 3.2 중복 코드 (Duplicated Code)
**문장 슬라이드하기**
    - 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 한다.
**함수 추출하기**
    - 함수를 추출하고, 추출된 메서드를 호출
**메서드 올리기**
    - 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있을 때

## 3.3 긴 함수 (Long Function)
>주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 
>함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 의도(intention)가 드러나게 짓는다.
>이렇게 함수로 묶는 코드는 여러 줄일 수도 있고 단 한 줄일 수도 있다. 심지어 원래 코드보다 길어지더라도 함수로 뽑는다.
>단, 함수 이름에 코드의 목적을 드러내야 한다.

**함수 추출하기**
    - 함수 본문에서 묶어 빼내기 좋은 코드 덩이리를 찾아 새로운 함수로 만든다.

함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다.
    **임시 변수를 질의 함수로 바꾸기** : 임시 변수의 수를 줄이고
    **매개변수 객체 만들기**, **객체 통째로 넘기기** : 매개변수의 수를 줄인다.
    이후에도 여전히 임시 변수와 매개변수가 너무 많다면 **함수를 명령으로 바꾸기**를 고려한다.

추출할 코드는 어떻게 찾아낼까?
**주석**은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있는 경우가 많다. 
이런 주석을 찾으면 주석이 설명하는 코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다.
>코드가 단 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.

**조건문**이나 **반복문**도 추출 대상의 실마리를 제공한다.

**조건문 분해하기**
switch문을 구성하는 case문마다 함수 추출하기를 적용하여, 각 case의 본문을 함수 호출문 하나로 바꾼다.
같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 **조건부 로직을 다형성으로 바꾸기**를 적용한다.

반복문도 그 안의 코드와 함께 추출하여 독립된 함수로 만든다.
추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있기 때문일 수 있다.
이럴 때는 과감히 **빤복문 쪼개기**를 적용해서 작업을 분리한다.


## 3.4 긴 매개변수 목록 (Long Parameter List)
**매개변수를 질의 함수로 바꾸기** : 다른 매개변수에서 값을 얻어올 수 있는 매개변수를 제거
**객체 통째로 넘기기** : 데이터 구조에서 값을 뽑아 각각 별개의 매개변수로 전달하는 코드에 원본 데이터 구조를 그대로 전달
**매개변수 객체 만들기** : 항상 함께 전달되는 매개변수들을 하나로 묶는다
**플래그 인수 제거하기** : 함수의 동작 방식을 정하는 플래그 역할의 매개변수를 제거
**여러 함수를 클래스로 묶기** : 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때, 공통 값을 클래스의 필드로 정의


## 3.5 전역 데이터 (Global Data)
전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 매커니즘이 없다.
**변수 캡슐화하기** 

## 3.6 가변 데이터 (Mutable Data)
**변수 캡슐화하기** : 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
**변수 쪼개기** : 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우에, 용도별로 독립 변수에 저장한다.
**질의 함수와 변경 함수 분리하기** : 
**세터 제거하기**

**파생 변수를 질의 함수로 바꾸기**

**여러 함수를 클래스로 묶기** , **여러 함수를 변환 함수로 묶기**  : 변수를 갱신하는 코드들의 유효범위를 (클래스나 변환으로) 제한
**참조를 값으로 바꾸기** : 내부 필드에 데이터를 담고 있는 변수라면, 내부 필드를 직접 수정하지 않고 구조체를 통째로 교체


## 3.7 뒤엉킨 변경 (Divergent Change)
단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다. (하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때
- 지원해야 할 데이터베이스가 추가될 때마다 함수 세 개를 바꾼다든지
- 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야 한다든지

**단계 쪼개기** : 다음 맥락에 필요한 데이터를 특정한 데이터 구조로 담아 전달하는 방식으로 단계 분리
**함수 옮기기** : 각 맥락에 해당하는 적당한 모듈을 만들어 관련 함수를 모음
**함수 추출하기** : 여러 맥락의 일에 관여하는 함수
**클래스 추출하기** : 맥락별 분리 방법


## 3.8 산탄총 수술 (Shotgun Surgery)




1. 미스테리한 이름: 변수, 함수, 클래스 등의 이름이 불분명할 때 발생하는 문제
2. 중복 코드: 동일하거나 유사한 코드가 여러 곳에 존재하는 경우3.
3. 긴 함수: 함수가 너무 길어 이해하기 어려운 경우3.
4. 긴 매개변수 목록: 함수의 매개변수가 너무 많은 경우3.
5. 전역 데이터: 전역 변수의 사용으로 인한 문제3.
6. 가변 데이터: 데이터 변경이 예측하기 어려운 방식으로 이루어지는 경우3.
7. 뒤엉킨 변경: 하나의 모듈이 여러 이유로 자주 변경되는 경우5.
8. 기능 편애: 한 모듈이 다른 모듈의 데이터를 과도하게 사용하는 경우3.
9. 데이터 뭉치: 여러 곳에서 함께 사용되는 데이터 그룹3.
10. 기본형 집착: 기본 데이터 타입을 과도하게 사용하는 경우3.
11. 반복되는 switch문: 동일한 switch 문이 여러 곳에서 반복되는 경우3.
12. 반복문: 복잡한 반복문 로직으로 인해 코드 이해와 유지보수가 어려워지는 문제.
13. 성의 없는 요소: 실질적인 기능이 없거나 너무 단순한 클래스나 메서드로 인해 불필요한 복잡성을 야기하는 문제.
14. 추측성 일반화: 미래에 필요할 것이라 예상하고 만든 불필요한 추상화나 기능으로 인한 복잡성 증가 문제. 
15. 임시 필드: 특정 상황에서만 사용되는 인스턴스 변수로 인해 클래스 이해도가 떨어지는 문제. 
16. 메시지 체인: 객체 요청이 연쇄적으로 이어져 과도한 결합도를 야기하는 문제3. 
17. 중개자: 클래스가 다른 클래스에 단순히 위임만 하는 경우 불필요한 복잡성을 야기하는 문제6. 
18. 내부자 거래: 클래스 간 과도한 데이터 공유로 인한 결합도 증가 문제. 
19. 거대한 클래스: 너무 많은 필드와 메서드를 가진 클래스로 인한 복잡성과 유지보수 어려움. 
20. 서로 다른 인터페이스의 대안 클래스들: 유사한 기능을 하지만 다른 인터페이스를 가진 클래스들로 인한 일관성 부족 문제. 
21. 데이터 클래스: 데이터만 가지고 있고 행위가 없는 클래스로 인한 캡슐화 부족 문제. 
22. 상속 포기: 부모 클래스의 메서드나 데이터를 사용하지 않는 자식 클래스로 인한 상속 구조의 문제. 
23. 주석: 불필요하거나 오해의 소지가 있는 주석으로 인한 코드 이해도 저하 문제. 
24. 여러 겹의 네스팅: 과도한 중첩 구조로 인해 코드 가독성과 유지보수성이 떨어지는 문제.

