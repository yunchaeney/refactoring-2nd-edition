# Chapter 01

## 1.3 리팩터링의 첫 단계
: 리팩토링에서 테스트의 역할은 굉장히 중요하다.

> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

## 1.4 statement() 함수 쪼개기
### 01.ts : 함수 추출하기
1. **함수 추출하기** : switch문 분리
2. 테스트 하기
> 오류가 생기더라도 변경 폭이 작기 때문에 살펴볼 범위도 좁아서 문제를 찾고 해결하기가 훨씬 쉽다.
> 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심이다.
> 한번에 너무 많이 수정하려다 실수를 저지르면 디버깅하기 어려워서 결과적으로 작업 시간이 늘어난다.
> 조금씩 수정하여 피드백 주기를 짧게 가져가는 습관이 이러한 재앙을 피하는 길이다.
>> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

3. 변수의 이름을 명확한 형태로 바꾼다. (thisAmount를 result로, perf를 aPerformance로)

### 02.ts : 임시 변수를 질의 함수로 바꾸기, 변수 인라인하기
4. play 변수 제거하기
> aPerformance는 루프 변수에서 오기 때문에 반복문을 한번 돌 때마다 자연스레 값이 변경된다.
> 하지만 play는 개별 공연에서 얻기 때문에 애초에 매개변수로 전달할 필요가 없다.
--> **임시 변수를 질의 함수로 바꾸기**
5. thisAmount 변수 제거하기


### 03.ts : 적립 포인트 계산 코드 추출, 함수 선언 바꾸기
### 04.ts : 반복문 쪼개기, 문장 슬라이드하기
**반복문 쪼개기(split loop)** : volumnCredits 는 반복문 한 바퀴를 돌 때마다 값을 누적하기 때문에, 누적되는 부분은 반복문을 쪼개 분리한다.
1. volumnCredits 누적 로직을 별도로 분리
2. **문장 슬라이드**를 통해 volumnCredits 선언부를 사용하는 반복문 앞으로 옮기기
3. 해당하는 부분을 **별도 함수로 추출**
4. **변수 인라인**하여 volumnCredits 변수를 없애기

totalAmount 도 같은 방식으로 재거한다.


## 1.5 중간 점검: 난무하는 중첩 함수
> 때로는 리팩터링이 성능에 상당한 영향을 주기도 한다. 그런 경우라도 나는 개의치 않고 리팩터링한다. 잘 다듬어진 코드라야 성능 개선 작업도 훨씬 수월하기 때문이다.
> 특별한 경우가 아니라면 일단 무시하라.
> 리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.


## 1.6 계산 단계와 포맷팅 단계 분리하기
> 복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일만큼 중요하다.

단계 쪼개기 : 02.ts
1. 첫 단계에서 필요한 데이터를 처리하고, 다음 단계에서 앞서 처리한 결과를 텍스트나 HTML로 표현하자.
2. 두 번째 단계가 될 코드들을 **함수 추출하기**로 뽑아내야 한다.

반복문을 파이프라인으로 바꾸기 : 03.ts


## 1.7 다형성을 활용해 계산 코드 재구성하기
**조건부 로직을 다형성으로 바꾸기** : if문이 여러 개 생길 때 , switch문에서, 앞으로 케이스가 더 추가될 얘정일 때 : 다형성 적용 (객체지향)
**타입 코드를 서브클래스로 바꾸기**
**생성자를 팩터리 함수로 바꾸기**


> 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.